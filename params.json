{"name":"Violetear","tagline":"Go HTTP router","body":"[![GoDoc](https://godoc.org/github.com/nbari/violetear?status.svg)](https://godoc.org/github.com/nbari/violetear)\r\n[![Build Status](https://drone.io/github.com/nbari/violetear/status.png)](https://drone.io/github.com/nbari/violetear/latest)\r\n[![Circle CI](https://circleci.com/gh/nbari/violetear.svg?style=svg)](https://circleci.com/gh/nbari/violetear)\r\n[![Build Status](https://travis-ci.org/nbari/violetear.svg?branch=master)](https://travis-ci.org/nbari/violetear)\r\n[![Coverage](http://gocover.io/_badge/github.com/nbari/violetear?0)](http://gocover.io/github.com/nbari/violetear)\r\n[![Coverage Status](https://coveralls.io/repos/nbari/violetear/badge.svg?branch=develop&service=github)](https://coveralls.io/github/nbari/violetear?branch=develop)\r\n[![codecov.io](http://codecov.io/github/nbari/violetear/coverage.svg?branch=master)](http://codecov.io/github/nbari/violetear?branch=master)\r\n\r\n# violetear\r\nGo HTTP router\r\n\r\n### Design Goals\r\n* Keep it simple and small, avoiding extra complexity at all cost. [KISS](http://en.wikipedia.org/wiki/KISS_principle)\r\n* Support for static and dynamic routing.\r\n* Easy middleware compatibility so that it satisfies the http.Handler interface.\r\n* Trace Request-ID per request.\r\n\r\nPackage [GoDoc](https://godoc.org/github.com/nbari/violetear)\r\n\r\nHow it works\r\n------------\r\n\r\nThe router is capable off handle any kind or URI static,\r\ndynamic or catchall and based on the\r\n[HTTP request Method](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)\r\naccept or discard the request.\r\n\r\nFor example, suppose we have an API that exposes a service that allow to ping\r\nany IP address.\r\n\r\nTo handle only \"GET\" request for any IPv4 addresss:\r\n\r\n    http://api.violetear.org/command/ping/127.0.0.1\r\n                            \\______/\\___/\\________/\r\n                                |     |      |\r\n                                 static      |\r\n                                          dynamic\r\n\r\nThe router ``HandlerFunc``  would be:\r\n\r\n    router.HandleFunc(\"/command/ping/:ip\", ip_handler, \"GET\")\r\n\r\nFor this to work, first the a regex matching ``:ip`` should be added:\r\n\r\n    router.AddRegex(\":ip\", `^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$`)\r\n\r\nNow let's say you also want to be available to ping ipv6 or any host:\r\n\r\n    http://api.violetear.org/command/ping/*\r\n                            \\______/\\___/\\_/\r\n                                |     |   |\r\n                                 static   |\r\n                                       catch-all\r\n\r\nA catch-all could be used and also a different handler, for example:\r\n\r\n    router.HandleFunc(\"/command/ping/*\", any_handler, \"GET, HEAD\")\r\n\r\nThe * indicates the router to behave like a catch-all therefore it\r\nwill match anything after the ``/command/ping/`` if no other condition matches\r\nbefore.\r\n\r\nNotice also the \"GET, HEAD\", that indicates that only does HTTP methods will be\r\naccepted, and any other will not be allowed, router will return a 405 the one\r\ncan also be customised.\r\n\r\n\r\nUsage\r\n-----\r\n\r\n**HandleFunc**:\r\n\r\n     func HandleFunc(path string, handler http.HandlerFunc, http_methods ...string)\r\n\r\n**Handle** (useful for middleware):\r\n\r\n     func Handle(path string, handler http.Handler, http_methods ...string)\r\n\r\n**http_methods** is a comma separted list of allowed HTTP methods, example:\r\n\r\n    router.HandleFunc(\"/view\", handleView, \"GET, HEAD\")\r\n\r\n**AddRegex** adds a \":named\" regular expression to the dynamicRoutes, example:\r\n\r\n    router.AddRegex(\":ip\", `^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$`)\r\n\r\n\r\nBasic example:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"github.com/nbari/violetear\"\r\n    \"log\"\r\n    \"net/http\"\r\n)\r\n\r\nfunc catchAll(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"I'm catching all\\n\"))\r\n}\r\n\r\nfunc handleGET(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"I handle GET requests\\n\"))\r\n}\r\n\r\nfunc handlePOST(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"I handle POST requests\\n\"))\r\n}\r\n\r\nfunc handleUUID(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"I handle dynamic requests\\n\"))\r\n}\r\n\r\nfunc main() {\r\n    router := violetear.New()\r\n    router.LogRequests = true\r\n    router.Request_ID = \"Request-ID\"\r\n\r\n    router.AddRegex(\":uuid\", `[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}`)\r\n\r\n    router.HandleFunc(\"*\", catchAll)\r\n    router.HandleFunc(\"/method\", handleGET, \"GET\")\r\n    router.HandleFunc(\"/method\", handlePOST, \"POST\")\r\n    router.HandleFunc(\"/:uuid\", handleUUID, \"GET,HEAD\")\r\n\r\n    log.Fatal(http.ListenAndServe(\":8080\", router))\r\n}\r\n```\r\n\r\nRunning this code will show something like this:\r\n\r\n```sh\r\n$ go run test.go\r\n2015/10/22 17:14:18 Adding path: * [ALL]\r\n2015/10/22 17:14:18 Adding path: /method [GET]\r\n2015/10/22 17:14:18 Adding path: /method [POST]\r\n2015/10/22 17:14:18 Adding path: /:uuid [GET,HEAD]\r\n```\r\n\r\n> test.go contains the code show above\r\n\r\nTesting using curl or [http](https://github.com/jkbrzt/httpie)\r\n\r\nAny request 'catch-all':\r\n\r\n```sh\r\n$ http POST http://localhost:8080/\r\nHTTP/1.1 200 OK\r\nContent-Length: 17\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:18:49 GMT\r\nRequest-Id: POST-1445527129854964669-1\r\n\r\nI'm catching all\r\n```\r\n\r\nA GET request:\r\n\r\n```sh\r\n$ http http://localhost:8080/method\r\nHTTP/1.1 200 OK\r\nContent-Length: 22\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:43:25 GMT\r\nRequest-Id: GET-1445528605902591921-1\r\n\r\nI handle GET requests\r\n```\r\n\r\nA POST request:\r\n\r\n```sh\r\n$ http POST http://localhost:8080/method\r\nHTTP/1.1 200 OK\r\nContent-Length: 23\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:44:28 GMT\r\nRequest-Id: POST-1445528668557478433-2\r\n\r\nI handle POST requests\r\n```\r\n\r\nA dynamic request using an [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) as the URL resource:\r\n\r\n```sh\r\n$ http http://localhost:8080/50244127-45F6-4210-A89D-FFB0DA039425\r\nHTTP/1.1 200 OK\r\nContent-Length: 26\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:45:33 GMT\r\nRequest-Id: GET-1445528733916239110-5\r\n\r\nI handle dynamic requests\r\n```\r\n\r\nTrying to use POST on the ``/:uuid`` resource will cause a\r\n*Method not Allowed 405* this because only ``GET`` and ``HEAD``\r\nmethods are allowed:\r\n\r\n```sh\r\n$ http POST http://localhost:8080/50244127-45F6-4210-A89D-FFB0DA039425\r\nHTTP/1.1 405 Method Not Allowed\r\nContent-Length: 19\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:47:19 GMT\r\nRequest-Id: POST-1445528839403536403-6\r\nX-Content-Type-Options: nosniff\r\n\r\nMethod Not Allowed\r\n```\r\n\r\nRequest_ID\r\n-----------\r\n\r\nTo keep track of the \"requests\" an existing \"request ID\" can be used, for\r\nexample when using AppEngine the name of the header containing the request ID is\r\n**Request-ID** therefore to continue using it, the router needs to know the name\r\nof the header:\r\n\r\n    router := violetear.New()\r\n    router.Request_ID = \"Request-ID\"\r\n\r\nIf the proxy is using another name, for example \"RID\" then use something like:\r\n\r\n    router := violetear.New()\r\n    router.Request_ID = \"RID\"\r\n\r\nIf ``router.Request_ID`` is not set, no \"request ID\" is going to be added to the\r\nheaders, if it is set but not headers found from the request headers, one will\r\nbe created.\r\n\r\nThis can be extended using a middleware same has the logger.\r\n\r\n\r\nNotFoundHandler\r\n---------------\r\n\r\nFor defining a custom ``http.Handler`` to handle **404 Not Found** example:\r\n\r\n    ...\r\n\r\n    func my404() http.Handler {\r\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n            http.Error(w, \"ne ne ne\", 404)\r\n        })\r\n    }\r\n\r\n    func main() {\r\n        router := violetear.New()\r\n        router.NotFoundHandler = my404()\r\n        ...\r\n\r\nNotAllowedHandler\r\n-----------------\r\n\r\nFor defining a custom ``http.Handler`` to handle **405 Method Not Allowed**.\r\n\r\nPanicHandler\r\n------------\r\n\r\nFor using a custom http.HandlerFunc to handle panics\r\n\r\nMiddleware\r\n----------\r\n\r\nVioletear uses [Alice](http://justinas.org/alice-painless-middleware-chaining-for-go/) to handle [middleware](middleware).\r\n\r\nExample:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"github.com/nbari/violetear\"\r\n    \"github.com/nbari/violetear/middleware\"\r\n    \"log\"\r\n    \"net/http\"\r\n)\r\n\r\nfunc commonHeaders(next http.Handler) http.Handler {\r\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n        w.Header().Set(\"X-app-Version\", \"1.0\")\r\n        next.ServeHTTP(w, r)\r\n    })\r\n}\r\n\r\nfunc middlewareOne(next http.Handler) http.Handler {\r\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n        log.Println(\"Executing middlewareOne\")\r\n        next.ServeHTTP(w, r)\r\n        log.Println(\"Executing middlewareOne again\")\r\n    })\r\n}\r\n\r\nfunc middlewareTwo(next http.Handler) http.Handler {\r\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n        log.Println(\"Executing middlewareTwo\")\r\n        if r.URL.Path != \"/\" {\r\n            return\r\n        }\r\n        next.ServeHTTP(w, r)\r\n        log.Println(\"Executing middlewareTwo again\")\r\n    })\r\n}\r\n\r\nfunc catchAll(w http.ResponseWriter, r *http.Request) {\r\n    log.Println(\"Executing finalHandler\")\r\n    w.Write([]byte(\"I catch all\"))\r\n}\r\n\r\nfunc foo(w http.ResponseWriter, r *http.Request) {\r\n    log.Println(\"Executing finalHandler\")\r\n    w.Write([]byte(\"foo\"))\r\n}\r\n\r\nfunc main() {\r\n    router := violetear.New()\r\n\r\n    stdChain := middleware.New(commonHeaders, middlewareOne, middlewareTwo)\r\n\r\n    router.Handle(\"/\", stdChain.ThenFunc(catchAll), \"GET,HEAD\")\r\n    router.Handle(\"/foo\", stdChain.ThenFunc(foo), \"GET,HEAD\")\r\n    router.HandleFunc(\"/bar\", foo)\r\n\r\n    log.Fatal(http.ListenAndServe(\":8080\", router))\r\n}\r\n```\r\n\r\n> Notice the use or router.Handle and router.HandleFunc when using middleware\r\nyou normally would use route.Handle\r\n\r\nRequest output example:\r\n\r\n```sh\r\n$ http http://localhost:8080/\r\nHTTP/1.1 200 OK\r\nContent-Length: 11\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 16:08:18 GMT\r\nRequest-Id: GET-1445530098002701428-3\r\nX-App-Version: 1.0\r\n\r\nI catch all\r\n```\r\n\r\nOn the server you will see something like this:\r\n\r\n```sh\r\n$ go run test.go\r\n2015/10/22 18:07:55 Adding path: / [GET]\r\n2015/10/22 18:07:55 Adding path: /foo [GET]\r\n2015/10/22 18:07:55 Adding path: /bar [ALL]\r\n2015/10/22 18:08:18 Executing middlewareOne\r\n2015/10/22 18:08:18 Executing middlewareTwo\r\n2015/10/22 18:08:18 Executing finalHandler\r\n2015/10/22 18:08:18 Executing middlewareTwo again\r\n2015/10/22 18:08:18 Executing middlewareOne again\r\n```\r\n\r\nMore references:\r\n\r\n* http://www.alexedwards.net/blog/making-and-using-middleware\r\n* https://justinas.org/alice-painless-middleware-chaining-for-go/\r\n\r\n\r\nCanonicalized headers issues\r\n----------------------------\r\n\r\nGo version < 1.5 will canonicalize the header (from uppercase to lowercase),\r\nexample:\r\n\r\nhttps://travis-ci.org/nbari/violetear/jobs/81059152#L156 golang 1.4\r\n\r\nhttps://travis-ci.org/nbari/violetear/jobs/81059153#L156 golang 1.5\r\n","google":"UA-69163599-1","note":"Don't delete this file! It's used internally to help with page regeneration."}